7월 8일

문제 출처 : swea 20671번

소요 시간 : 약 4시간 + a 

난이도 : d5

키워드 : 수학 모듈러 조합론 ...

너무 어려웠다. 이산수학적인 발상이 상당히 난이도 있다..
(풀이)

먼저 입력은 <string,int> 로 받는다. int는 카드 번호이고, 따라서 총 2N의 길이가 된다.
2N길이의 배열을 정렬한다. 이 떄 "순서대로 고르면 항상 최소 값이 되게" 정렬한다.
처음에 단순히 사전순 정렬하면 된다고 생각했지만
13, 131 같은 경우 사전 역순으로 뽑은 수가 더작다.
따라서 사전순이 아닌 a+b < b+a 로 정렬해야한다.

정렬된 배열의 각 pair가 전체 answer에 얼마만큼 기여하는가를 2N만큼 순회하면서 계산할 것이다.

pair.fisrt에 담긴 value가 모든 경우에서 어느 자리에 위치하는지 찾아야한다.
즉, 각각의 경우의 수에서 value보다 오른쪽에 있는 수의 길이를 찾으면 된다. 이 길이를 length라고 하면
value의 기여는  sum(value * 10^length) for all length 이고, value는 상수이므로 결론적으로
sum(10^length) for all length을 구하면 된다.

여기서 핵심 아이디어가 적용되는데, 우선 뒤에서부터 계산할 것이다.
맨 뒤의 pair는 2^(N-1)의 경우에 항상 맨뒤에 오므로, padding 없이 그대로 2^(N-1)을 곱해서 전체에 누적시키면된다.
이제 뒤에서부터 두번 째를 계산해보자.
맨 뒤 페어의 길이 L0에 대해
맨 뒤 페어를 골랐을 경우 2^(N-2) * 10^(L0)
맨 뒤 페어를 고르지 않았을 경우 2^(N-2) * 10^(0) 이므로 각각을 전체에 누적시키면 된다.
즉 2^(N-2) * (10^L0 + 10^0)

여기서 이제 일반화를 해야 하는데, 과정은 매우 힘들었지만 결과적으로 다음과 같이 일반화할 수 있었다.

N개의 항 (10^0 + 10^0) * (10^0 + 10^0) ... * (10^0 + 10^0) = 2^N
으로 출발한다 i번째 항은 카드 i를 뜻한다.

각각의 페어에서 자기 자신의 번호와 같은 항을 제외하고 나머지 N-1개의 항을 곱한 값을 사용하면 된다.

여기서 정렬된 페어 마지막에 j번째 카드를 처리했다고 하자
그럼 j번 째 항을 (10^L0 + 10^0) 으로 바꾼다.
(원래는 j번 째 카드를 고를 수 없었기 때문에 j번 째 카드는 항상 길이 0만큼을 기여했지만, j번째 카드를 처리하고 나면 j번째 카드를 고를 수 있게 되고, 이 때 L0만큼 기여한다)
(즉 각항은 결과적으로 (10^L0 + 10^L1)이 되는데 여기서 왼쪽항을 고른다는 건 j번째 카드의 L0(앞면)을 사용해서 L0만큼의 기여를 받는다는 뜻)

이렇게 곱한 값을 구한뒤 , value까지 곱해주고, answer에 누적시키면 된다.